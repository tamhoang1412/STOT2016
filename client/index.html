
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=620"/>
    <title>WebRTC Demo: Stream your mp3s</title>
    <script src="js/adapter.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.4.0/clipboard.min.js"></script>

    <script src="js/jquery.js"></script>
    <script src="css/bootstrap/js/bootstrap.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <script src="js/id3-minimized.js"></script>
    <style>
      #holder { border: 10px dashed #ccc; width: 300px; height: 300px; margin: 20px auto;}
      #holder.hover { border: 10px dashed #333; }
      #holder.background { background-size:100% 100%; background-repeat:no-repeat;}
    </style>
    <link rel="stylesheet" href="css/style.css">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="css/bootstrap/css/bootstrap.css"/>
    <link rel="stylesheet" href="css/bootstrap/css/bootstrap.min.css"/>
  </head>

  <body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Listening Together</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="active" id="room"><a>Sharing link<span class="sr-only">(current)</span></a></li>
          </ul>
          <ul class="nav navbar-nav">
            <li><a>Listener: <span id="counter">0</span></a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/tamhoang1412/STOT2016">Github</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
    <div class=col-md-6>
      <div id="blockcontent">
        <article style="align: center;">
          <div id="holder"></div>

          <div style="text-align: center; color: white">
            <label id="meta">&nbsp;</label>
          </div>
          <div class="introTit">
            Introduction:
          </div>
          <div class="intro">
            Drag music file into the box.<br>
            Click "Sharing Link" to get shared link.<br>
            Listener showing number of listener.<br>
          </div>
        </article>
      </div>
    </div>

    <div id="chatPage"></div>
    <script>
      $(function(){
          $("#chatPage").load("chat.html"); 
        });
    </script>
    <div class="footer">
      <p id="status">The required APIs are not supported by your browser. Please try again using <a href="http://www.google.com/chrome">Chrome</a>.</p>
    </div>
  </body>

    <script lang="javascript">

      // references to UI elements that need to be updated
      var holder = document.getElementById('holder');
      var state = document.getElementById('status');
      var room = document.getElementById('room');
      var counter = document.getElementById('counter');
      var meta = document.getElementById('meta');
      var pcConstraint;
      var dataConstraint;

    // Check for the various File API support.
    if (window.File
      && window.FileReader
      && window.FileList
      && window.Blob
      && RTCPeerConnection
      && (window.AudioContext || window.webkitAudioContext)) {

      window.AudioContext = window.AudioContext || window.webkitAudioContext;

      if (navigator.webkitGetUserMedia) {
        state.className = 'success';
        state.innerHTML = 'All the required APIs are available.'
      } else {
        state.className = 'fail';
        state.innerHTML = 'This demo requires Chrome for playing mp3 encoded media.'
      }
    } else {
      state.className = 'fail';
    }

    // handle file drops
    holder.ondragover = function () { this.className = 'hover'; return false; };
    holder.ondragend = function () { this.className = ''; return false; };
    holder.ondrop = handleFileDrop;

    // socket connection to the signalling server
    var socket = io.connect();

    // setup media objects
    var context = new AudioContext();
    var currentStream;
    var gainNode = context.createGain();
    var mediaSource, mediaBuffer, remoteDestination, mediaDescription;
    var muted, start, stop;
    gainNode.connect(context.destination);

    // webrtc connection configuration
    var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};

    // keep track of peers and the id of this session
    var peers = {};
    var myId;

    // after connecting to the server an ID for this session is received and saved.
    socket.on('your-id', function(id) {
      myId = id;
      console.log('id = ' + id);
      var clientURL = window.location.protocol + '//' + window.location.host + '/listen.html?id=' + myId;
      room.innerHTML = '<a href="' + clientURL + '" target="_blank">' + 'Sharing Link' + '</a>';
    });

    socket.on('disconnected', function(from) {
      peers[from] = undefined;
    });

    // when a listener logs on to the sessions we'll setup webrtc signalling for the session and check if we can start
    // streaming media
    socket.on('logon', function(message) {
      console.log("log on");
      pcConstraint = null;
      window.pc = new RTCPeerConnection(pc_config, pcConstraint);

      

      var from = message.from;
      peers[from] = { peerconnection: pc, stream: undefined };

      // create a data channel for sending the media description
      dataConstraint = null;
      peers[from].dataChannel = peers[from].peerconnection.createDataChannel('mediaDescription', dataConstraint);
      pc.onicecandidate = function(event) {
        socket.emit('message', { from: myId, to: message.from, data: { type: 'candidate', candidate: event.candidate } } );  
      }

      peers[from].dataChannel.onopen = sendMediaDescription(peers[from].dataChannel);

      

      peers[from].dataChannel.onopen = function() {
        startPlayingIfPossible(from);
      };

      peers[from].peerconnection.createOffer(function(desc) {
        gotDescription(from, desc);
      }, failed);

      counter.innerHTML = Object.keys(peers).length;
    });

    // when a listener leaves remove the rtc stream for that peer
    socket.on('logoff', function(message) {
      console.log('received logoff message');

      try {
        peers[message.from].peerconnection.removeStream(peers[message.from].stream);
      } catch (err) {

      }

        peers[message.from].stream = undefined;
        delete peers[message.from];
      counter.innerHTML = Object.keys(peers).length;
    });

    // when a message is received from a listener we'll update the rtc session accordingly
    socket.on('message', function(message) {
      console.log('Received message: ' + JSON.stringify(message.data));
      if (message.data.type === 'candidate') {
        if (message.data.candidate) {
          peers[message.from].peerconnection.addIceCandidate(new RTCIceCandidate(message.data.candidate));
          console.log("candidate" + peers[message.from].dataChannel.readyState);
        }
      } else if (message.data.type === 'sdp') {
        peers[message.from].peerconnection.setRemoteDescription(new RTCSessionDescription(message.data.sdp));
        console.log("sdp" + peers[message.from].dataChannel.readyState);
      }
    });

    // is called when SDP is received from a connected listener
    function gotDescription(from, desc) {
      peers[from].peerconnection.setLocalDescription(desc);
      socket.emit('message', { from: myId, to: from, data: { type: 'sdp', sdp: desc } });
    }

    // checks if media is present and starts streaming media to a connected listener if possible
    function startPlayingIfPossible(from) {
      // add the stream to the peerconnection for this connection
      if (mediaSource && remoteDestination) {
        var constraints = { mandatory: {}, optional: [] };
        // constraints.optional[0] = { 'bandwidth' : 100 }; // does not seem to influence quality
        peers[from].peerconnection.addStream(remoteDestination.stream, constraints);
        peers[from].stream = remoteDestination.stream;
        peers[from].peerconnection.createOffer(function(desc) {
          gotDescription(from, desc);
        }, failed);
        sendMediaDescription(peers[from].dataChannel);
      }
    }

    // Sends media meta information over a rtc data channel to a connected listener

    function sendMediaDescription(channel) {
      console.log(mediaDescription);
      channel.readyState = 'open';
      if (mediaDescription && channel.readyState === 'open') {
        var data = JSON.stringify(mediaDescription);
        channel.send(data);
      }
    }

    function onDataChannelOpen() {
      sendMediaDescription(this);
    }

    function failed(code) {
        log("Failure callback: " + code);
      }

      // is called when a file is dropped in the drop zone
      function handleFileDrop(event) {
        // stop the current stream.
        //stopStream();

      this.className = '';
      event.preventDefault();
      var file = event.dataTransfer.files[0];
      mediaDescription = {};

      // load the meta-data from the mp3
      ID3.loadTags(file.name, function() {
        mediaDescription.artist = 'Unknown';
          mediaDescription.title = 'Untitled';

          var tags = ID3.getAllTags(file.name);
          console.log(tags.artist + " - " + tags.title + ", " + tags.album);

          mediaDescription.artist = tags.artist;
          mediaDescription.title = tags.title;

          if ('picture' in tags) {
            var image = tags.picture;

            mediaDescription.image = {};
            mediaDescription.image.format = image.format;
            mediaDescription.image.size = image.data.length;

            // mediaDescription.image.base64 = Base64.encodeBytes(image.data);

            holder.style.background = 'url("data:' + image.format + ';base64,' + Base64.encodeBytes(image.data) + '") no-repeat center';
          } else {
            holder.style.background = 'url("res/no-artwork.png")';
          }

          holder.style.backgroundSize = "295px 295px";

          meta.innerHTML = 'Playing ' + mediaDescription.title + ' by ' + mediaDescription.artist;
      }, { 
        tags: ["artist", "title", "album", "year", "comment", "track", "genre", "lyrics", "picture"],
        dataReader: new FileAPIReader(file)
      });

      if (file.type.match('audio*')) {
        var reader = new FileReader();
        // read the mp3 and decode the audio.
        reader.onload = (function(readEvent) {
          context.decodeAudioData(readEvent.target.result, function(buffer) {
            if (mediaSource) {
              mediaSource.stop(0);
            }
            mediaBuffer = buffer;
            playStream();
            start = Date.now();
          });
        });
        reader.readAsArrayBuffer(file);
      }
      return false;
    }

    // starts playing a media stream from a given offset.
      function playStream(offset) {
        offset = offset ? offset : 0;
        mediaSource = context.createBufferSource();
        mediaSource.buffer = mediaBuffer;
        mediaSource.start(0, offset / 1000);
        mediaSource.connect(gainNode);
        // setup remote stream
        remoteDestination = context.createMediaStreamDestination();
        mediaSource.connect(remoteDestination);

        for (var peer in peers) {
          startPlayingIfPossible(peer);
        }
      }

      // stops playing the stream and removes the stream from peer connections
      function stopStream() {
        for (var peer in peers) {
          if (peers[peer].stream) {
            peers[peer].stream.stop();
            peers[peer].peerconnection.removeStream(peers[peer].stream);
            peers[peer].stream = undefined;
          }
        }
        if (mediaSource) mediaSource.stop(0);
      }
    </script>

</html>