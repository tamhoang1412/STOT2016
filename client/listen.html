<!doctype html>
<html>
	<head>
	    <meta charset="utf-8">
		<script src="js/adapter.js"></script>
		<script src="/socket.io/socket.io.js"></script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.4.0/clipboard.min.js"></script>
		<script src="js/jquery.js"></script>
		<script src="css/bootstrap/js/bootstrap.js"></script>
		
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
		<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
		<style>
			#holder { border: 10px dashed #ccc; width: 300px; height: 300px; margin: 20px auto;}
			#holder.hover { border: 10px dashed #333; }
			#holder.background { background-size:100% 100%; background-repeat:no-repeat;}
		</style>
		<link rel="stylesheet" href="css/style.css">
		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="css/bootstrap/css/bootstrap.css"/>
		<link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
	</head>

	<body>
		<nav class="navbar navbar-default">
			<div class="container-fluid">
				<!-- Brand and toggle get grouped for better mobile display -->
				<div class="navbar-header">
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="#">Listening Together</a>
				</div>

				<!-- Collect the nav links, forms, and other content for toggling -->
				<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
					<ul class="nav navbar-nav">
						<li class="active"><a>ID</a></li>
					</ul>
					<ul class="nav navbar-nav navbar-right">
						<li><a href="https://github.com/tamhoang1412/STOT2016">Github</a></li>
					</ul>
				</div><!-- /.navbar-collapse -->
			</div><!-- /.container-fluid -->
		</nav>
		<div id="blockcontent" class="col-md-6">
			<article style="align: center;">
				<div style="text-align: center;">
					<p id='rate' style="text-align: center; color: white">&nbsp;</p>
				</div>
				<br>
				<div style="text-align: center;" class="audio_box">
					<audio controls id="player" autoplay/>
						Your browser does not support the audio element.
					</audio>
				</div>
				<p id='meta' style="text-align: center; color: white">&nbsp;</p>
			</article>
		</div>
		<div id="chatPage"></div>
		<script>
			$(function(){
		      $("#chatPage").load("chat.html"); 
		    });
		</script>
	</body>

    <script lang="javascript">
    	// getting the session id from the request URI
		var urlParams;
		(window.onpopstate = function () {
		    var match,
		        pl     = /\+/g,  // Regex for replacing addition symbol with a space
		        search = /([^&=]+)=?([^&]*)/g,
		        decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
		        query  = window.location.search.substring(1);

		    urlParams = {};
		    while (match = search.exec(query))
		       urlParams[decode(match[1])] = decode(match[2]);
		})();

		if (!window.chrome) {
			alert('This page needs Google Chrome to play correctly.');
		}

		window.AudioContext = window.AudioContext || window.webkitAudioContext;

		var context = new AudioContext();

	// UI elements that can be updated
 		var player = document.getElementById('player');
 		var rate = document.getElementById('rate');
 		var meta = document.getElementById('meta');
 		var pcConstraint;
		var dataConstraint;

		// check for required APIs
		if (RTCPeerConnection) {
		} else {
			alert('The required APIs are not fully supported in this browser.');
		}

		// configuration for peer connections
		var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};

		// connect to the server
		var socket = io.connect();

		// references to the id of this listener and the id of the host.
		var myId;
		var to = urlParams.id;

		// id of the listener is received from the server
		socket.on('your-id', function(id) {
			myId = id;
			console.log('id = ' + id);
			// send logon message to the host
			socket.emit('logon', { from: myId, to: to } );
		});

		socket.on('error', function(message) {
			alert(message);
		});

		window.onbeforeunload = function(e) {
			player.pause();
			socket.emit('logoff', { from: myId, to: to } );
			for (var i=0;i<1000;i++){
	    		// do something unnoticable but time consuming like writing a lot to console
  				console.log('buying some time to finish sending data'); 
			};
		};
	
		// creates a peer connection
		pcConstraint = null;
		window.pc = new RTCPeerConnection(pc_config, pcConstraint);

		// creates a data channel to receive meta data
		dataConstraint = null;
		var dataChannel = pc.createDataChannel('mediaDescription', dataConstraint);

		pc.onicecandidate = function(event) {
			socket.emit('message', { from: myId, to: to, data: { type: 'candidate', candidate: event.candidate } });
		}

		pc.ondatachannel = function (event) {
      console.log('Receive Channel Callback');
		  dataChannel = event.channel;
		  dataChannel.onmessage = onReceiveMessageCallback;
		  dataChannel.onopen = onReceiveChannelStateChange;
		  dataChannel.onclose = onReceiveChannelStateChange;
		};

		function onReceiveMessageCallback (event) {
			console.log("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
			try {
				var mediaDescription = JSON.parse(event.data);
		    	meta.innerHTML = 'Listening to ' + mediaDescription.title + ' by ' + mediaDescription.artist;
			} catch (err) {
				console.log(err);
			}
		}

		function updateMediaDescription() {
			console.log('media description received');
		}
		function onReceiveChannelStateChange() {
		  var readyState = dataChannel.readyState;
		  console.log('Receive channel state is: ' + readyState);
		}

		

		// when a message is received add it to the peerconnection accordingly
		socket.on('message', function(message) {
			console.log('Received message: ' + JSON.stringify(message.data));
			console.log(dataChannel.readyState);
			
			if (message.data.type === 'candidate') {
				if (message.data.candidate) {
					console.log('adding an ice candidate');
					pc.addIceCandidate(new RTCIceCandidate(message.data.candidate), onAddIceCandidateSuccess, onAddIceCandidateError);
					console.log(dataChannel.readyState);
				}
			} else if (message.data.type === 'sdp') {
				console.log('setting remote description and creating answer.')
				pc.setRemoteDescription(new RTCSessionDescription(message.data.sdp));
				pc.createAnswer(function(desc) {
						pc.setLocalDescription(desc);
						socket.emit('message', { from: myId, to: message.from, data: { type: 'sdp', sdp: desc} } );
					}, failedCreateAnswer);
				console.log(dataChannel.readyState);
			}
		});

    pc.onaddstream = gotRemoteStream;

    // when a media stream is received attach it to the media element.
  	function gotRemoteStream(event) {
  		console.log('Got remote stream.');
  		attachMediaStream(player, event.stream);
  		player.play();
  		monitorBitrate();
  		player.onloadeddata = function (event) {
  			console.log(event);
  		}
  		player.onprogress = function (event) {
  			console.log(event);
  		}
  	}

  	var timestampPrev = 0;
  	var bytesPrev;
  	var monitorInterval;

  	function monitorBitrate() {
  		if (monitorInterval) {
    		timestampPrev = 0;
  			bytesPrev = 0;
	    }

  		monitorInterval = setInterval(function() {
    		if (pc.getRemoteStreams()[0]) {
    			pc.getStats(function(stats) {
    				var bitrateTxt = 'No bitrate stats';
    				var results = stats.result();
    				for (var i in results) {
    					var result = results[i];
    					if (!result.local || result.local === result) {
    						if (result.type === 'ssrc') {
    							var bytesNow = result.stat('bytesReceived');
    							if (timestampPrev > 0) {
    								var bitrate = Math.round((bytesNow - bytesPrev) * 8 / (result.timestamp - timestampPrev));
    								if (bitrate > 0) {
    									var bitrateTxt = 'Received in ' + bitrate + ' kbits/sec';
    								}	
    							}
    							timestampPrev = result.timestamp;
    							bytesPrev = bytesNow;
    						}
    					}
						rate.innerHTML = bitrateTxt;
    				}
    			});
    		}
  		}, 1000);
  	}

 	  function failedCreateAnswer(error) {
    	console.log("Failure callback from createAnswer: " + JSON.stringify(error));
		}

  	function failedSetRemoteDescription(error) {
    	console.log("Failure callback from setRemoteDescription: " + JSON.stringify(error));
		}

		function onAddIceCandidateSuccess() {
		  console.log('AddIceCandidate success.');
		}

		function onAddIceCandidateError(error) {
		 	console.log('Failed to add Ice Candidate: ' + error.toString());
		}
    </script>
</html>